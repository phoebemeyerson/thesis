---
title: "fire_analysis"
author: "Phoebe Meyerson"
date: "2024-01-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(here)
library(mapview)
library(mase)
library(sf)
library(sfdep)
library(survey)
library(INLA)
library(tidyverse)
library(Matrix)
library(matrixcalc)
```

```{r}
# LOADING DATA
m333_fire <- readRDS("m333_fire.rds")
data <- readRDS("dat_fire.rds") %>%
  mutate(tnt = case_when( # refactor tnt as indicator variable
    tnt == 1 ~ 1,
    tnt == 2 ~ 0
  )) %>%
  mutate(
    DOMAIN = SUBSECTION,
    PROVINCE = "M333"
  ) %>%
  rename(tcc = tcc16) %>%
  filter(rep < 1001)
fire_pop_dat <- readRDS("fire_pop_dat.rds")

fire_list <- data %>%
  group_by(rep) %>%
  group_split()

rm(data)

fire_true_est <- fire_pop_dat %>%
  group_by(SUBSECTION) %>%
  summarize(true_val = mean(DRYBIO),
            true_sd = sd(DRYBIO))

np <- (fire_pop_dat %>% 
  group_by(SUBSECTION) %>%
  count())$n

domains <- unique(fire_true_est$SUBSECTION)

fire_prop_tnt <- fire_pop_dat %>%
  group_by(SUBSECTION) %>%
  summarize(tnt1 = mean(tnt)) %>%
  mutate(tnt0 = 1 - tnt1) %>%
  pivot_longer(cols = !(SUBSECTION), names_to = "tnt", values_to = "prop") %>%
  mutate(tnt = parse_number(tnt))

fire_prop_split <- fire_prop_tnt %>%
  group_by(SUBSECTION) %>%
  group_split()

# making new adjacency matrix
m333f_contig <- st_contiguity(m333_fire)
m333f_contig_sf <- st_as_edges(st_centroid(m333_fire$geometry), nb = m333f_contig)
ggplot() + geom_sf(data = m333_fire) +
  geom_sf(data = m333f_contig_sf) + ggtitle("Contiguous Neighbors")

m333_fire_adj <- wt_as_matrix(m333f_contig, st_weights(m333f_contig, style = "B"))

fire_feature_ids <- c("M333Ah", "M333Ag", "M333Ae", "M333Ad", "M333Ab", "M333Aa", "M333Ba", "M333Bb", "M333Bc", "M333Cb", "M333Cc","M333Ca", "M333Cf", "M333Ai", "M333Da", "M333Ac", "M333Cg", "M333Ce", "M333Db", "M333Dd", "M333Ch", "M333De", "M333DcFIRE", "M333Dc")

# need to check whether these rownames are accurate
rownames(m333_fire_adj) <- fire_feature_ids
colnames(m333_fire_adj) <- fire_feature_ids

fire_true_est_sma <- fire_true_est %>%
  mutate(SUBSECTION = factor(SUBSECTION, levels = fire_feature_ids)) %>%
  arrange(SUBSECTION)

```


```{r}
# ESTIMATOR FUNCTIONS

# horvitz-thompson estimator
get_direct <- function(formula, by, sample_des, r, truth, CI = 0.95) {
  res <- svyby(formula, by, design = sample_des, svymean, na.rm = T)
  out_dat <- data.frame(
    region = as.vector(res[[all.vars(by)[1]]]),
    est = as.vector(model.matrix(formula, res)[, 2]),
    var = res$se ^ 2) %>% 
    mutate(
    lower = est + qnorm((1-CI)/2) * res$se,
    upper = est + qnorm(1 - (1-CI)/2) * res$se,
    method = "HT",
    rep = r,
    true_val = truth)
  return(out_dat)
}


# post-stratified estimator
get_poststrat <- function(samp_list, N, prop_list, domains, r, truth) {
  out_dat <- data.frame(region = c(), 
                        est = c(),
                        var = c(),
                        lower = c(),
                        upper = c(),
                        method = c(),
                        rep = c(),
                        true_val = c())

  for (i in 1:length(domains)) {
    pop_prop_i <- prop_list[[i]] %>% select(tnt, prop)
    samp_i <- samp_list[[i]]

    PS <- postStrat(y = samp_i$DRYBIO, N = N[i], 
                        xsample = samp_i$tnt, xpop = pop_prop_i,
                        datatype = "means", var_est = TRUE,
                        var_method = "SRSunconditional")
    PS_est_i <- data.frame(
      region = domains[i],
      est = PS$pop_mean,
      var = PS$pop_mean_var,
      lower = PS$pop_mean - 1.96*sqrt(PS$pop_mean_var),
      upper = PS$pop_mean + 1.96*sqrt(PS$pop_mean_var),
      method = "PS",
      rep = r,
      true_val = truth[i]
    )
    out_dat <- rbind(out_dat, PS_est_i)
  }
  return(out_dat)
}

# generalized regression estimator
get_greg <- function(working_fit, formula, by,
                     pop_dat, sample_des, r, truth, CI = 0.95) {
  pop_unit_ests <- as.vector(predict(working_fit, pop_dat,
                                     type = "response")) 
  area_ests <-
    aggregate(pop_unit_ests, 
              list(region = as.vector(pop_dat[[all.vars(by)[1]]])),
              mean)
  colnames(area_ests)[2] <- "working_est"
  sample_des$variables$res <- 
    sample_des$variables[[all.vars(formula)[1]]] -
    as.vector(predict(working_fit, sample_des$variables, type = "response")) 
  sample_des$variables$region <- 
    as.vector(sample_des$variables[[all.vars(by)[1]]])
  res_ht <- svyby(~res, ~region, sample_des, svymean)
  out_dat <- left_join(area_ests, res_ht, by = "region") %>%
    mutate(est = working_est + res,
           var = se^2,
           method = "GREG", 
           rep = r,
           lower = est + qnorm((1-CI) / 2) * se,
           upper = est + qnorm(1- (1 - CI) / 2) * se,
           true_val = truth) %>%
    select(region, est, var, lower, upper, method, rep, true_val)
  return(out_dat)
}

# spatially smoothed model-assisted estimator
get_ssma <- function(direct_est, adj_mat, r, truth,
                     pc_u = 5, pc_alpha = 0.01, 
                     pc_u_phi = 0.5, pc_alpha_phi = 2/3, CI = .95) {
  hyperpc_bym_int <- list(
    prec = list(prior = "pc.prec", param = c(pc_u , pc_alpha)),  
    phi = list(prior = 'pc', param = c(pc_u_phi , pc_alpha_phi))
  )
  sd_dat <- direct_est %>%
    mutate(est = ifelse(est != 0 & est != 1 & var > 1e-5, est, NA)) %>%
    mutate(prec = 1 / var,
           region = match(region, rownames(adj_mat)))
  sd_fit <-
    INLA::inla(est ~ f(region, model = "bym2", 
                       graph = adj_mat, 
                       hyper = hyperpc_bym_int, 
                       scale.model = TRUE),
               family = "gaussian", data = sd_dat, 
               scale = sd_dat$prec,
               control.family = 
                 list(hyper = list(prec = list(initial= log(1), fixed= TRUE))),
               control.predictor = list(compute = TRUE),
               control.compute=list(config = TRUE),
               safe = TRUE)
  
  sd_fit_sample <-
    inla.posterior.sample(n = 1000, sd_fit,
                          list(region = 1:nrow(adj_mat), "(Intercept)" = 1))
  sd_est_mat <-
    do.call(cbind, lapply(sd_fit_sample,
                          function(x) x$latent[1:nrow(adj_mat)] +
                            x$latent[nrow(adj_mat) + 1]))
  out_dat <- data.frame(region = rownames(adj_mat),
                        est = rowMeans(sd_est_mat),
                        var = apply(sd_est_mat, 1, var),
                        lower = apply(sd_est_mat, 1,
                                      function(x) quantile(x, (1-CI)/2)),
                        upper = apply(sd_est_mat, 1,
                                      function(x) quantile(x, 1-(1-CI)/2)),
                        method = "SMA",
                        rep = r,
                        true_val = truth)
  return(out_dat)
}

```

```{r}
# ACTUAL SIMULATION: HT, PS, GREG
nreps <- 50 # change to length(dat_list)
fire_results <- data.frame(region = c(), 
                      est = c(),
                      var = c(),
                      lower = c(),
                      upper = c(),
                      method = c(),
                      rep = c(),
                      true_val = c()) # add SD if needed later

for (i in 1:nreps) {
  rep_dat <- fire_list[[i]]

  # pre processing
  sample_des <- svydesign(id = ~1,
                          data = rep_dat,
                          weights = ~weights)
  
  rep_split <- rep_dat %>%
    group_by(SUBSECTION) %>%
    group_split()
  
  fit <- svyglm(DRYBIO ~ tcc + tnt + tcc*tnt, sample_des)
  
  # HT estimates
  fire_results <- rbind(fire_results, get_direct(~DRYBIO, ~SUBSECTION, sample_des, 
                                       i, fire_true_est$true_val))
  
  # PS estimates
  fire_results <- rbind(fire_results, get_poststrat(rep_split, np, fire_prop_split, 
                                          domains, i, fire_true_est$true_val))
  
  # GREG estimates
  GREG_est <- get_greg(fit, ~DRYBIO, ~SUBSECTION, 
                       fire_pop_dat, sample_des, i, fire_true_est$true_val)
  fire_results <- rbind(fire_results, GREG_est)
  
  print(i)
}
```

```{r}
# ACTUAL SIMULATION: SSMA
s <- 26
e <- 50
# NEED TO REORDER TRUE VAL TO MATCH FEATURE ID ORDER

for (i in s:e) {
  # get GREG estimates
  GREG_est <- fire_results %>%
    filter(method == "GREG" & rep == i)
  
  # SMA estimates
  fire_results <- rbind(fire_results, get_ssma(GREG_est, m333_fire_adj, i, fire_true_est_sma$true_val))
  print(i)
}
```

```{r}
# METRICS 
# will create separate file once results are larger
fire_metrics <- fire_results %>%
  group_by(method, region) %>%
  mutate(cov_rate = mean(ifelse(true_val >= lower & true_val <= upper, 1, 0)),
         emp_mean = mean(est),
         emp_var = mean((est - emp_mean)^2),
         emp_mse = mean((est - true_val)^2),
         prb = (emp_mean - true_val) / true_val * 100,
         prb_mse = mean((emp_mse - var) / var * 100)) %>%
  dplyr::select(method, region, true_val, cov_rate, emp_mean, 
                emp_var, emp_mse, prb, prb_mse) %>%
  mutate(method = factor(method, levels = c("HT", "PS", "GREG", "SMA"))) %>%
  unique()

fire_metrics %>% filter(region == "M333DcFIRE")

ggplot(fire_results, aes(x = method, y = est)) +
  geom_boxplot()

moreres <- fire_results %>% 
  filter(region == "M333DcFIRE") %>%
  group_by(method) %>%
  mutate(emp_mean = mean(est),
         method = factor(method, levels = c("HT", "PS", "GREG", "SMA"))) 

dcfire_true <- (fire_true_est %>% filter(SUBSECTION == "M333DcFIRE"))$true_val
dc_true <- (fire_true_est %>% filter(SUBSECTION == "M333Dc"))$true_val

ggplot(moreres, aes(x = method, y = est)) +
  geom_boxplot() +
  geom_hline(yintercept = dcfire_true, col = "hotpink", lwd = 1.2) +
  geom_hline(yintercept = dc_true, col = "darkblue", lwd = 1.2, linetype = "dashed") +
  theme_minimal()

```

